=== tests/cases/compiler/genericMappedTypeAcceptsInferredObjectType.ts ===
interface Constraint {
>Constraint : Symbol(Constraint, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 0, 0))

	foo: string
>foo : Symbol(Constraint.foo, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 0, 22))
}

interface ExtendedConstraint extends Constraint {
>ExtendedConstraint : Symbol(ExtendedConstraint, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 2, 1))
>Constraint : Symbol(Constraint, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 0, 0))

	bar: string
>bar : Symbol(ExtendedConstraint.bar, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 4, 49))
}

type GenericMap<T> = {
>GenericMap : Symbol(GenericMap, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 6, 1))
>T : Symbol(T, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 8, 16))

	[P in keyof T]: T[P]
>P : Symbol(P, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 9, 2))
>T : Symbol(T, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 8, 16))
>T : Symbol(T, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 8, 16))
>P : Symbol(P, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 9, 2))
}

type OptionalGenericMap<T> = {
>OptionalGenericMap : Symbol(OptionalGenericMap, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 10, 1))
>T : Symbol(T, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 12, 24))

	[P in keyof T]?: T[P]
>P : Symbol(P, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 13, 2))
>T : Symbol(T, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 12, 24))
>T : Symbol(T, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 12, 24))
>P : Symbol(P, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 13, 2))
}

const required = <T>(x: GenericMap<T>) => x
>required : Symbol(required, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 16, 5))
>T : Symbol(T, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 16, 18))
>x : Symbol(x, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 16, 21))
>GenericMap : Symbol(GenericMap, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 6, 1))
>T : Symbol(T, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 16, 18))
>x : Symbol(x, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 16, 21))

const optional = <T>(x: OptionalGenericMap<T>) => x
>optional : Symbol(optional, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 17, 5))
>T : Symbol(T, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 17, 18))
>x : Symbol(x, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 17, 21))
>OptionalGenericMap : Symbol(OptionalGenericMap, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 10, 1))
>T : Symbol(T, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 17, 18))
>x : Symbol(x, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 17, 21))

const withinConstraint = <T extends Constraint>(foo: T['foo']) => {
>withinConstraint : Symbol(withinConstraint, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 19, 5))
>T : Symbol(T, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 19, 26))
>Constraint : Symbol(Constraint, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 0, 0))
>foo : Symbol(foo, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 19, 48))
>T : Symbol(T, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 19, 26))

	required<Constraint>({ foo }) // no error as { foo: T['foo'] } <: GenericMap<Constraint>
>required : Symbol(required, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 16, 5))
>Constraint : Symbol(Constraint, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 0, 0))
>foo : Symbol(foo, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 20, 23))

	required<T>({ foo }) // error as { foo: T['foo'] } /<: GenericMap<T> because other properties may be missing
>required : Symbol(required, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 16, 5))
>T : Symbol(T, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 19, 26))
>foo : Symbol(foo, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 21, 14))

	optional<T>({}) // no error as {} <: OptionalGenericMap<Constraint>
>optional : Symbol(optional, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 17, 5))
>T : Symbol(T, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 19, 26))

	optional<T>({ foo }) // no error as { foo: T['foo'] } <: OptionalGenericMap<T>
>optional : Symbol(optional, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 17, 5))
>T : Symbol(T, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 19, 26))
>foo : Symbol(foo, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 23, 14))
}

const withinExtendedConstraint = <T extends ExtendedConstraint>(foo: T['foo'], bar: T['bar']) => {
>withinExtendedConstraint : Symbol(withinExtendedConstraint, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 26, 5))
>T : Symbol(T, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 26, 34))
>ExtendedConstraint : Symbol(ExtendedConstraint, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 2, 1))
>foo : Symbol(foo, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 26, 64))
>T : Symbol(T, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 26, 34))
>bar : Symbol(bar, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 26, 78))
>T : Symbol(T, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 26, 34))

	required<ExtendedConstraint>({ foo }) // error as { foo: T['foo'] } /<: GenericMap<ExtendedConstraint> because bar is missing
>required : Symbol(required, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 16, 5))
>ExtendedConstraint : Symbol(ExtendedConstraint, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 2, 1))
>foo : Symbol(foo, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 27, 31))

	required<ExtendedConstraint>({ bar }) // error as { bar: T['bar'] } /<: GenericMap<ExtendedConstraint> because foo is missing
>required : Symbol(required, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 16, 5))
>ExtendedConstraint : Symbol(ExtendedConstraint, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 2, 1))
>bar : Symbol(bar, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 28, 31))

	required<ExtendedConstraint>({ foo, bar }) // no error as { foo: T['foo'], bar: T['bar'] } <: GenericMap<ExtendedConstraint>
>required : Symbol(required, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 16, 5))
>ExtendedConstraint : Symbol(ExtendedConstraint, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 2, 1))
>foo : Symbol(foo, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 29, 31))
>bar : Symbol(bar, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 29, 36))

	required<T>({ foo, bar }) // error as { foo: T['foo'], bar: T['bar'] } /<: GenericMap<T> because other properties may be missing
>required : Symbol(required, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 16, 5))
>T : Symbol(T, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 26, 34))
>foo : Symbol(foo, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 30, 14))
>bar : Symbol(bar, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 30, 19))

	optional<T>({}) // no error as {} <: OptionalGenericMap<T>
>optional : Symbol(optional, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 17, 5))
>T : Symbol(T, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 26, 34))

	optional<T>({ foo }) // no error as { foo: T['foo'] } <: OptionalGenericMap<T>
>optional : Symbol(optional, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 17, 5))
>T : Symbol(T, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 26, 34))
>foo : Symbol(foo, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 32, 14))

	optional<T>({ bar }) // no error as { bar: T['bar'] } <: OptionalGenericMap<T>
>optional : Symbol(optional, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 17, 5))
>T : Symbol(T, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 26, 34))
>bar : Symbol(bar, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 33, 14))

	optional<T>({ foo, bar }) // no error as { foo: T['foo'], bar: T['bar'] } <: OptionalGenericMap<T>
>optional : Symbol(optional, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 17, 5))
>T : Symbol(T, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 26, 34))
>foo : Symbol(foo, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 34, 14))
>bar : Symbol(bar, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 34, 19))
}

function shouldReject<T, K extends keyof T>(key: K, v: T[K]): {[k in keyof T]?: T[k]} {
>shouldReject : Symbol(shouldReject, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 35, 1))
>T : Symbol(T, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 37, 22))
>K : Symbol(K, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 37, 24))
>T : Symbol(T, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 37, 22))
>key : Symbol(key, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 37, 44))
>K : Symbol(K, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 37, 24))
>v : Symbol(v, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 37, 51))
>T : Symbol(T, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 37, 22))
>K : Symbol(K, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 37, 24))
>k : Symbol(k, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 37, 64))
>T : Symbol(T, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 37, 22))
>T : Symbol(T, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 37, 22))
>k : Symbol(k, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 37, 64))

	return { [key]: v }
>[key] : Symbol([key], Decl(genericMappedTypeAcceptsInferredObjectType.ts, 38, 9))
>key : Symbol(key, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 37, 44))
>v : Symbol(v, Decl(genericMappedTypeAcceptsInferredObjectType.ts, 37, 51))

    // Type '{ [x: string]: T[K]; }' is not assignable to type '{ [k in keyof T]?: T[k] | undefined; }'.(2322)
}

