tests/cases/conformance/types/typeParameters/typeArgumentLists/inferPartialTypeArgumentsErrors.ts(2,5): error TS1338: 'infer' declarations with a name are only permitted in the 'extends' clause of a conditional type.
tests/cases/conformance/types/typeParameters/typeArgumentLists/inferPartialTypeArgumentsErrors.ts(2,14): error TS2345: Argument of type '42' is not assignable to parameter of type 'Q'.
tests/cases/conformance/types/typeParameters/typeArgumentLists/inferPartialTypeArgumentsErrors.ts(5,52): error TS2345: Argument of type '{ a: ("x" | "y")[]; }' is not assignable to parameter of type '{ a?: "z"[]; b?: "z"[]; }'.
  Types of property 'a' are incompatible.
    Type '("x" | "y")[]' is not assignable to type '"z"[]'.
      Type '"x" | "y"' is not assignable to type '"z"'.
        Type '"x"' is not assignable to type '"z"'.
tests/cases/conformance/types/typeParameters/typeArgumentLists/inferPartialTypeArgumentsErrors.ts(11,58): error TS2345: Argument of type '{ b: ("z" | "x" | "y")[]; }' is not assignable to parameter of type '{ a?: ("x" | "y")[]; b?: ("x" | "y")[]; }'.
  Types of property 'b' are incompatible.
    Type '("z" | "x" | "y")[]' is not assignable to type '("x" | "y")[]'.
      Type '"z" | "x" | "y"' is not assignable to type '"x" | "y"'.
        Type '"z"' is not assignable to type '"x" | "y"'.
tests/cases/conformance/types/typeParameters/typeArgumentLists/inferPartialTypeArgumentsErrors.ts(18,60): error TS2345: Argument of type '{ c: "y"[]; }' is not assignable to parameter of type '{ a?: "x"[]; b?: "x"[]; c?: "x"[]; }'.
  Types of property 'c' are incompatible.
    Type '"y"[]' is not assignable to type '"x"[]'.
      Type '"y"' is not assignable to type '"x"'.
tests/cases/conformance/types/typeParameters/typeArgumentLists/inferPartialTypeArgumentsErrors.ts(20,52): error TS1346: 'infer' declarations without a name are only permitted in the top of a type argument list


==== tests/cases/conformance/types/typeParameters/typeArgumentLists/inferPartialTypeArgumentsErrors.ts (6 errors) ====
    declare function foo<A>(x: A): A;
    foo<infer Q>(42); // Can't name the `infer` targets
        ~~~~~~~
!!! error TS1338: 'infer' declarations with a name are only permitted in the 'extends' clause of a conditional type.
                 ~~
!!! error TS2345: Argument of type '42' is not assignable to parameter of type 'Q'.
    
    declare function testConstraints1<A extends B, B extends string>(arg?: { a?: A[], b?: B[] }): { a: A[], b: B[] }
    const expectError1 = testConstraints1<infer, "z"> ({ a: ["x", "y"] });
                                                       ~~~~~~~~~~~~~~~~~
!!! error TS2345: Argument of type '{ a: ("x" | "y")[]; }' is not assignable to parameter of type '{ a?: "z"[]; b?: "z"[]; }'.
!!! error TS2345:   Types of property 'a' are incompatible.
!!! error TS2345:     Type '("x" | "y")[]' is not assignable to type '"z"[]'.
!!! error TS2345:       Type '"x" | "y"' is not assignable to type '"z"'.
!!! error TS2345:         Type '"x"' is not assignable to type '"z"'.
    
    declare function testConstraints2<A extends string, B extends A>(arg?: { a?: A[], b?: B[] }): { a: A[], b: B[] }
    const expectAllowed1 = testConstraints2<infer, "x"> ({ a: ["x", "y"] }); // OK { a: string[], b: "x"[] }
    const expectAllowed2 = testConstraints2<"x" | "y", infer> ({ b: ["x"] }); // OK { a: ("x" | "y")[], b: ("x" | "y")[] }
    const expectAllowed3 = testConstraints2<infer, "z"> ({ a: ["x", "y"] }); // OK - inference fails, but that just makes A = string, which still passes
    const expectError2 = testConstraints2<"x" | "y", infer> ({ b: ["x", "y", "z"] }); // error "z" not in "x" | "y"
                                                             ~~~~~~~~~~~~~~~~~~~~~~
!!! error TS2345: Argument of type '{ b: ("z" | "x" | "y")[]; }' is not assignable to parameter of type '{ a?: ("x" | "y")[]; b?: ("x" | "y")[]; }'.
!!! error TS2345:   Types of property 'b' are incompatible.
!!! error TS2345:     Type '("z" | "x" | "y")[]' is not assignable to type '("x" | "y")[]'.
!!! error TS2345:       Type '"z" | "x" | "y"' is not assignable to type '"x" | "y"'.
!!! error TS2345:         Type '"z"' is not assignable to type '"x" | "y"'.
    
    declare function complexConstraints<A extends string, B extends A, C extends B>(arg: { a?: A[], b?: B[], c?: C[] }): { a: A[], b: B[], c: C[] };
    const expectAllowed4 = complexConstraints<"x" | "y" | "z", infer, infer> ({ a: ["x"], c: ["x", "y"] }); // OK { a: ("x" | "y" | "z")[], b: ("x" | "y" | "z")[], c: ("x" | "y")[] }
    // OK because B inferred to be "x" but that conflicts with C as "x" | "y" so inference fails - A and C are provided,
    // B becomes its constraint, A, or "x" | "y" | "z", and the call successfully resolves
    const expectAlllowed5 = complexConstraints<"x" | "y" | "z", infer, "x" | "y">({b: ["x"]});
    const expectError3 = complexConstraints<"x", infer, infer>({c: ["y"]}); // error "y" does not extend "x"
                                                               ~~~~~~~~~~
!!! error TS2345: Argument of type '{ c: "y"[]; }' is not assignable to parameter of type '{ a?: "x"[]; b?: "x"[]; c?: "x"[]; }'.
!!! error TS2345:   Types of property 'c' are incompatible.
!!! error TS2345:     Type '"y"[]' is not assignable to type '"x"[]'.
!!! error TS2345:       Type '"y"' is not assignable to type '"x"'.
    
    type BadConditional = string extends { toString(): infer } ? true : false; // Must name infer target in conditionals
                                                       ~~~~~
!!! error TS1346: 'infer' declarations without a name are only permitted in the top of a type argument list
    