=== tests/cases/conformance/types/typeParameters/typeArgumentLists/inferPartialTypeArgumentsErrors.ts ===
declare function foo<A>(x: A): A;
>foo : Symbol(foo, Decl(inferPartialTypeArgumentsErrors.ts, 0, 0))
>A : Symbol(A, Decl(inferPartialTypeArgumentsErrors.ts, 0, 21))
>x : Symbol(x, Decl(inferPartialTypeArgumentsErrors.ts, 0, 24))
>A : Symbol(A, Decl(inferPartialTypeArgumentsErrors.ts, 0, 21))
>A : Symbol(A, Decl(inferPartialTypeArgumentsErrors.ts, 0, 21))

foo<infer Q>(42); // Can't name the `infer` targets
>foo : Symbol(foo, Decl(inferPartialTypeArgumentsErrors.ts, 0, 0))
>Q : Symbol(Q, Decl(inferPartialTypeArgumentsErrors.ts, 1, 9))

declare function testConstraints1<A extends B, B extends string>(arg?: { a?: A[], b?: B[] }): { a: A[], b: B[] }
>testConstraints1 : Symbol(testConstraints1, Decl(inferPartialTypeArgumentsErrors.ts, 1, 17))
>A : Symbol(A, Decl(inferPartialTypeArgumentsErrors.ts, 3, 34))
>B : Symbol(B, Decl(inferPartialTypeArgumentsErrors.ts, 3, 46))
>B : Symbol(B, Decl(inferPartialTypeArgumentsErrors.ts, 3, 46))
>arg : Symbol(arg, Decl(inferPartialTypeArgumentsErrors.ts, 3, 65))
>a : Symbol(a, Decl(inferPartialTypeArgumentsErrors.ts, 3, 72))
>A : Symbol(A, Decl(inferPartialTypeArgumentsErrors.ts, 3, 34))
>b : Symbol(b, Decl(inferPartialTypeArgumentsErrors.ts, 3, 81))
>B : Symbol(B, Decl(inferPartialTypeArgumentsErrors.ts, 3, 46))
>a : Symbol(a, Decl(inferPartialTypeArgumentsErrors.ts, 3, 95))
>A : Symbol(A, Decl(inferPartialTypeArgumentsErrors.ts, 3, 34))
>b : Symbol(b, Decl(inferPartialTypeArgumentsErrors.ts, 3, 103))
>B : Symbol(B, Decl(inferPartialTypeArgumentsErrors.ts, 3, 46))

const expectError1 = testConstraints1<infer, "z"> ({ a: ["x", "y"] });
>expectError1 : Symbol(expectError1, Decl(inferPartialTypeArgumentsErrors.ts, 4, 5))
>testConstraints1 : Symbol(testConstraints1, Decl(inferPartialTypeArgumentsErrors.ts, 1, 17))
>a : Symbol(a, Decl(inferPartialTypeArgumentsErrors.ts, 4, 52))

declare function testConstraints2<A extends string, B extends A>(arg?: { a?: A[], b?: B[] }): { a: A[], b: B[] }
>testConstraints2 : Symbol(testConstraints2, Decl(inferPartialTypeArgumentsErrors.ts, 4, 70))
>A : Symbol(A, Decl(inferPartialTypeArgumentsErrors.ts, 6, 34))
>B : Symbol(B, Decl(inferPartialTypeArgumentsErrors.ts, 6, 51))
>A : Symbol(A, Decl(inferPartialTypeArgumentsErrors.ts, 6, 34))
>arg : Symbol(arg, Decl(inferPartialTypeArgumentsErrors.ts, 6, 65))
>a : Symbol(a, Decl(inferPartialTypeArgumentsErrors.ts, 6, 72))
>A : Symbol(A, Decl(inferPartialTypeArgumentsErrors.ts, 6, 34))
>b : Symbol(b, Decl(inferPartialTypeArgumentsErrors.ts, 6, 81))
>B : Symbol(B, Decl(inferPartialTypeArgumentsErrors.ts, 6, 51))
>a : Symbol(a, Decl(inferPartialTypeArgumentsErrors.ts, 6, 95))
>A : Symbol(A, Decl(inferPartialTypeArgumentsErrors.ts, 6, 34))
>b : Symbol(b, Decl(inferPartialTypeArgumentsErrors.ts, 6, 103))
>B : Symbol(B, Decl(inferPartialTypeArgumentsErrors.ts, 6, 51))

const expectAllowed1 = testConstraints2<infer, "x"> ({ a: ["x", "y"] }); // OK { a: string[], b: "x"[] }
>expectAllowed1 : Symbol(expectAllowed1, Decl(inferPartialTypeArgumentsErrors.ts, 7, 5))
>testConstraints2 : Symbol(testConstraints2, Decl(inferPartialTypeArgumentsErrors.ts, 4, 70))
>a : Symbol(a, Decl(inferPartialTypeArgumentsErrors.ts, 7, 54))

const expectAllowed2 = testConstraints2<"x" | "y", infer> ({ b: ["x"] }); // OK { a: ("x" | "y")[], b: ("x" | "y")[] }
>expectAllowed2 : Symbol(expectAllowed2, Decl(inferPartialTypeArgumentsErrors.ts, 8, 5))
>testConstraints2 : Symbol(testConstraints2, Decl(inferPartialTypeArgumentsErrors.ts, 4, 70))
>b : Symbol(b, Decl(inferPartialTypeArgumentsErrors.ts, 8, 60))

const expectAllowed3 = testConstraints2<infer, "z"> ({ a: ["x", "y"] }); // OK - inference fails, but that just makes A = string, which still passes
>expectAllowed3 : Symbol(expectAllowed3, Decl(inferPartialTypeArgumentsErrors.ts, 9, 5))
>testConstraints2 : Symbol(testConstraints2, Decl(inferPartialTypeArgumentsErrors.ts, 4, 70))
>a : Symbol(a, Decl(inferPartialTypeArgumentsErrors.ts, 9, 54))

const expectError2 = testConstraints2<"x" | "y", infer> ({ b: ["x", "y", "z"] }); // error "z" not in "x" | "y"
>expectError2 : Symbol(expectError2, Decl(inferPartialTypeArgumentsErrors.ts, 10, 5))
>testConstraints2 : Symbol(testConstraints2, Decl(inferPartialTypeArgumentsErrors.ts, 4, 70))
>b : Symbol(b, Decl(inferPartialTypeArgumentsErrors.ts, 10, 58))

declare function complexConstraints<A extends string, B extends A, C extends B>(arg: { a?: A[], b?: B[], c?: C[] }): { a: A[], b: B[], c: C[] };
>complexConstraints : Symbol(complexConstraints, Decl(inferPartialTypeArgumentsErrors.ts, 10, 81))
>A : Symbol(A, Decl(inferPartialTypeArgumentsErrors.ts, 12, 36))
>B : Symbol(B, Decl(inferPartialTypeArgumentsErrors.ts, 12, 53))
>A : Symbol(A, Decl(inferPartialTypeArgumentsErrors.ts, 12, 36))
>C : Symbol(C, Decl(inferPartialTypeArgumentsErrors.ts, 12, 66))
>B : Symbol(B, Decl(inferPartialTypeArgumentsErrors.ts, 12, 53))
>arg : Symbol(arg, Decl(inferPartialTypeArgumentsErrors.ts, 12, 80))
>a : Symbol(a, Decl(inferPartialTypeArgumentsErrors.ts, 12, 86))
>A : Symbol(A, Decl(inferPartialTypeArgumentsErrors.ts, 12, 36))
>b : Symbol(b, Decl(inferPartialTypeArgumentsErrors.ts, 12, 95))
>B : Symbol(B, Decl(inferPartialTypeArgumentsErrors.ts, 12, 53))
>c : Symbol(c, Decl(inferPartialTypeArgumentsErrors.ts, 12, 104))
>C : Symbol(C, Decl(inferPartialTypeArgumentsErrors.ts, 12, 66))
>a : Symbol(a, Decl(inferPartialTypeArgumentsErrors.ts, 12, 118))
>A : Symbol(A, Decl(inferPartialTypeArgumentsErrors.ts, 12, 36))
>b : Symbol(b, Decl(inferPartialTypeArgumentsErrors.ts, 12, 126))
>B : Symbol(B, Decl(inferPartialTypeArgumentsErrors.ts, 12, 53))
>c : Symbol(c, Decl(inferPartialTypeArgumentsErrors.ts, 12, 134))
>C : Symbol(C, Decl(inferPartialTypeArgumentsErrors.ts, 12, 66))

const expectAllowed4 = complexConstraints<"x" | "y" | "z", infer, infer> ({ a: ["x"], c: ["x", "y"] }); // OK { a: ("x" | "y" | "z")[], b: ("x" | "y" | "z")[], c: ("x" | "y")[] }
>expectAllowed4 : Symbol(expectAllowed4, Decl(inferPartialTypeArgumentsErrors.ts, 13, 5))
>complexConstraints : Symbol(complexConstraints, Decl(inferPartialTypeArgumentsErrors.ts, 10, 81))
>a : Symbol(a, Decl(inferPartialTypeArgumentsErrors.ts, 13, 75))
>c : Symbol(c, Decl(inferPartialTypeArgumentsErrors.ts, 13, 85))

// OK because B inferred to be "x" but that conflicts with C as "x" | "y" so inference fails - A and C are provided,
// B becomes its constraint, A, or "x" | "y" | "z", and the call successfully resolves
const expectAlllowed5 = complexConstraints<"x" | "y" | "z", infer, "x" | "y">({b: ["x"]});
>expectAlllowed5 : Symbol(expectAlllowed5, Decl(inferPartialTypeArgumentsErrors.ts, 16, 5))
>complexConstraints : Symbol(complexConstraints, Decl(inferPartialTypeArgumentsErrors.ts, 10, 81))
>b : Symbol(b, Decl(inferPartialTypeArgumentsErrors.ts, 16, 79))

const expectError3 = complexConstraints<"x", infer, infer>({c: ["y"]}); // error "y" does not extend "x"
>expectError3 : Symbol(expectError3, Decl(inferPartialTypeArgumentsErrors.ts, 17, 5))
>complexConstraints : Symbol(complexConstraints, Decl(inferPartialTypeArgumentsErrors.ts, 10, 81))
>c : Symbol(c, Decl(inferPartialTypeArgumentsErrors.ts, 17, 60))

type BadConditional = string extends { toString(): infer } ? true : false; // Must name infer target in conditionals
>BadConditional : Symbol(BadConditional, Decl(inferPartialTypeArgumentsErrors.ts, 17, 71))
>toString : Symbol(toString, Decl(inferPartialTypeArgumentsErrors.ts, 19, 38))

