=== tests/cases/compiler/init.ts ===
export interface A {
>A : Symbol(A, Decl(init.ts, 0, 0))

    a: true;
>a : Symbol(A.a, Decl(init.ts, 0, 20))
}

export interface B {
>B : Symbol(B, Decl(init.ts, 2, 1))

    b: true;
>b : Symbol(B.b, Decl(init.ts, 4, 20))
}

export function f(thing?: A | B): A | B { return null as any; };
>f : Symbol(f, Decl(init.ts, 6, 1))
>thing : Symbol(thing, Decl(init.ts, 8, 18))
>A : Symbol(A, Decl(init.ts, 0, 0))
>B : Symbol(B, Decl(init.ts, 2, 1))
>A : Symbol(A, Decl(init.ts, 0, 0))
>B : Symbol(B, Decl(init.ts, 2, 1))

=== tests/cases/compiler/utils.ts ===
import {A, B} from "./init";
>A : Symbol(A, Decl(utils.ts, 0, 8))
>B : Symbol(B, Decl(utils.ts, 0, 10))

export type Either = A | B;
>Either : Symbol(Either, Decl(utils.ts, 0, 28))
>A : Symbol(A, Decl(utils.ts, 0, 8))
>B : Symbol(B, Decl(utils.ts, 0, 10))

=== tests/cases/compiler/usage.ts ===
import {Either} from "./utils";
>Either : Symbol(Either, Decl(usage.ts, 0, 8))

import {f} from "./init";
>f : Symbol(f, Decl(usage.ts, 1, 8))

export function doThing() {
>doThing : Symbol(doThing, Decl(usage.ts, 1, 25))

    return f();
>f : Symbol(f, Decl(usage.ts, 1, 8))
}
