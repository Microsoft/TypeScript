=== tests/cases/compiler/narrowGenericTypeByInstanceOf.ts ===
// From #28560

function preserveParentParameters() {
>preserveParentParameters : () => void

  class Parent<T> {
>Parent : Parent<T>

    value: T;
>value : T
  }
  class Child<S> extends Parent<S> {
>Child : Child<S>
>Parent : Parent<S>

    other: S;
>other : S
  }

  function withNumber(p: Parent<number>) {
>withNumber : (p: Parent<number>) => void
>p : Parent<number>

    if (p instanceof Child) {
>p instanceof Child : boolean
>p : Parent<number>
>Child : typeof Child

      p;
>p : Child<number>

    } else {
      p;
>p : Parent<number>
    }
  }
  function withString(p: Parent<string>) {
>withString : (p: Parent<string>) => void
>p : Parent<string>

    if (p instanceof Child) {
>p instanceof Child : boolean
>p : Parent<string>
>Child : typeof Child

      p;
>p : Child<string>

    } else {
      p;
>p : Parent<string>
    }
  }
  function withGeneric<A>(p: Parent<A>) {
>withGeneric : <A>(p: Parent<A>) => void
>p : Parent<A>

    if (p instanceof Child) {
>p instanceof Child : boolean
>p : Parent<A>
>Child : typeof Child

      p;
>p : Child<A>

    } else {
      p;
>p : Parent<A>
    }
  }
}

function copyParameterStructurally() {
>copyParameterStructurally : () => void

  class Parent<T> {
>Parent : Parent<T>

    value: T;
>value : T
  }
  class Child<S> {
>Child : Child<S>

    value: S;
>value : S

    other: S;
>other : S
  }

  function withNumber(p: Parent<number>) {
>withNumber : (p: Parent<number>) => void
>p : Parent<number>

    if (p instanceof Child) {
>p instanceof Child : boolean
>p : Parent<number>
>Child : typeof Child

      p;
>p : Child<number>

    } else {
      p;
>p : Parent<number>
    }
  }
  function withString(p: Parent<string>) {
>withString : (p: Parent<string>) => void
>p : Parent<string>

    if (p instanceof Child) {
>p instanceof Child : boolean
>p : Parent<string>
>Child : typeof Child

      p;
>p : Child<string>

    } else {
      p;
>p : Parent<string>
    }
  }
  function withGeneric<A>(p: Parent<A>) {
>withGeneric : <A>(p: Parent<A>) => void
>p : Parent<A>

    if (p instanceof Child) {
>p instanceof Child : boolean
>p : Parent<A>
>Child : typeof Child

      p;
>p : Child<A>

    } else {
      p;
>p : Parent<A>
    }
  }
}

function useConstraint() {
>useConstraint : () => void

  // #17473
  interface Foo {
    foo: string;
>foo : string
  }

  class Bar<T extends Foo> {
>Bar : Bar<T>

    constructor(readonly bar: T) {}
>bar : T
  }

  let a: any;
>a : any

  if (a instanceof Bar) {
>a instanceof Bar : boolean
>a : any
>Bar : typeof Bar

    a.bar; // <-- a.bar should be 'Foo' instead of 'any'
>a.bar : any
>a : Bar<any>
>bar : any
  }
}

function enhanceConstraint() {
>enhanceConstraint : () => void

  class Parent<T extends 1 | 2 | 3 | 4> {
>Parent : Parent<T>

    value: T;
>value : T
  }
  class Child<T extends 1 | 2> extends Parent<T> {
>Child : Child<T>
>Parent : Parent<T>

    other: T;
>other : T
  }

  function simpleExtends(p: Parent<1 | 2 | 3 | 4>) {
>simpleExtends : (p: Parent<1 | 2 | 3 | 4>) => void
>p : Parent<1 | 2 | 3 | 4>

    if (p instanceof Child) {
>p instanceof Child : boolean
>p : Parent<1 | 2 | 3 | 4>
>Child : typeof Child

      p;
>p : Child<1 | 2>

    } else {
      p;
>p : Parent<1 | 2 | 3 | 4>
    }
  }
  function complexExtends(p: Parent<2 | 3>) {
>complexExtends : (p: Parent<2 | 3>) => void
>p : Parent<2 | 3>

    if (p instanceof Child) {
>p instanceof Child : boolean
>p : Parent<2 | 3>
>Child : typeof Child

      p;
>p : Child<any>

    } else {
      p;
>p : Parent<2 | 3>
    }
  }
  function impossibleExtends(p: Parent<3 | 4>) {
>impossibleExtends : (p: Parent<3 | 4>) => void
>p : Parent<3 | 4>

    if (p instanceof Child) {
>p instanceof Child : boolean
>p : Parent<3 | 4>
>Child : typeof Child

      p;
>p : Child<any>

    } else {
      p;
>p : Parent<3 | 4>
    }
  }
}

function dontWidenPointlessly() {
>dontWidenPointlessly : () => void

  class Query<T> {
>Query : Query<T>

    uses: T;
>uses : T
  }
  function f<T>(p: T[] | Query<T>) {
>f : <T>(p: Query<T> | T[]) => void
>p : Query<T> | T[]

    if (Array.isArray(p)) {
>Array.isArray(p) : boolean
>Array.isArray : (arg: any) => arg is any[]
>Array : ArrayConstructor
>isArray : (arg: any) => arg is any[]
>p : Query<T> | T[]

      p; // T[], so far so good
>p : T[]

    } else if (p instanceof Query) {
>p instanceof Query : boolean
>p : Query<T>
>Query : typeof Query

      p; // should be Query<T>, not Query<any>
>p : Query<T>
    }
  }
}

function multipleParameters() {
>multipleParameters : () => void

  class Parent<A, B> {
>Parent : Parent<A, B>

    a: A;
>a : A

    b: B;
>b : B
  }
  class Swapped<X, Y> extends Parent<Y, X> {
>Swapped : Swapped<X, Y>
>Parent : Parent<Y, X>

    x: X;
>x : X

    y: Y;
>y : Y
  }
  function checkSwapped(p: Parent<number, string>) {
>checkSwapped : (p: Parent<number, string>) => void
>p : Parent<number, string>

    if (p instanceof Swapped) {
>p instanceof Swapped : boolean
>p : Parent<number, string>
>Swapped : typeof Swapped

      p;
>p : Swapped<string, number>

    } else {
      p;
>p : Parent<number, string>
    }
  }
}

function inconsistentParameters() {
>inconsistentParameters : () => void

  class Parent<A, B> {
>Parent : Parent<A, B>

    a: A;
>a : A

    b: B;
>b : B
  }
  class Child<C> extends Parent<C, C> {
>Child : Child<C>
>Parent : Parent<C, C>

    c: C;
>c : C
  }
  function possible(p: Parent<number, number>) {
>possible : (p: Parent<number, number>) => void
>p : Parent<number, number>

    if (p instanceof Child) {
>p instanceof Child : boolean
>p : Parent<number, number>
>Child : typeof Child

      p;
>p : Child<number>

    } else {
      p;
>p : Parent<number, number>
    }
  }
  function impossible(p: Parent<number, string>) {
>impossible : (p: Parent<number, string>) => void
>p : Parent<number, string>

    if (p instanceof Child) {
>p instanceof Child : boolean
>p : Parent<number, string>
>Child : typeof Child

      p;
>p : Child<any>

    } else {
      p;
>p : Parent<number, string>
    }
  }
}

function union() {
>union : () => void

  class Parent<A> {
>Parent : Parent<A>

    a: A;
>a : A
  }
  class Child<B> extends Parent<B> {
>Child : Child<B>
>Parent : Parent<B>

    b: B;
>b : B
  }
  function multipleParents(
>multipleParents : (p: Parent<number> | Parent<string> | Parent<boolean>) => void

    p: Parent<number> | Parent<string> | Parent<boolean>
>p : Parent<number> | Parent<string> | Parent<boolean>

  ) {
    if (p instanceof Child) {
>p instanceof Child : boolean
>p : Parent<number> | Parent<string> | Parent<boolean>
>Child : typeof Child

      p;
>p : Child<number> | Child<string> | Child<boolean>

    } else {
      p;
>p : Parent<number> | Parent<string> | Parent<boolean>
    }
  }
  function mixedChildren(p: Parent<number> | Child<string>) {
>mixedChildren : (p: Parent<number> | Child<string>) => void
>p : Parent<number> | Child<string>

    if (p instanceof Child) {
>p instanceof Child : boolean
>p : Parent<number> | Child<string>
>Child : typeof Child

      p;
>p : Child<string>

    } else {
      p;
>p : Parent<number>
    }
  }
  function imcompatibleOptions(
>imcompatibleOptions : (p: Parent<number> | Parent<string> | { foo: boolean; }) => void

    p: Parent<number> | Parent<string> | { foo: boolean }
>p : Parent<number> | Parent<string> | { foo: boolean; }
>foo : boolean

  ) {
    if (p instanceof Child) {
>p instanceof Child : boolean
>p : Parent<number> | Parent<string> | { foo: boolean; }
>Child : typeof Child

      p;
>p : Child<any>

    } else {
      p;
>p : Parent<number> | Parent<string> | { foo: boolean; }
    }
  }
}

