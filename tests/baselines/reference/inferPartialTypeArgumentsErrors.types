=== tests/cases/conformance/types/typeParameters/typeArgumentLists/inferPartialTypeArgumentsErrors.ts ===
declare function foo<A>(x: A): A;
>foo : <A>(x: A) => A
>x : A

foo<infer Q>(42); // Can't name the `infer` targets
>foo<infer Q>(42) : any
>foo : <A>(x: A) => A
>42 : 42

declare function testConstraints1<A extends B, B extends string>(arg?: { a?: A[], b?: B[] }): { a: A[], b: B[] }
>testConstraints1 : <A extends B, B extends string>(arg?: { a?: A[]; b?: B[]; }) => { a: A[]; b: B[]; }
>arg : { a?: A[]; b?: B[]; }
>a : A[]
>b : B[]
>a : A[]
>b : B[]

const expectError1 = testConstraints1<infer, "z"> ({ a: ["x", "y"] });
>expectError1 : any
>testConstraints1<infer, "z"> ({ a: ["x", "y"] }) : any
>testConstraints1 : <A extends B, B extends string>(arg?: { a?: A[]; b?: B[]; }) => { a: A[]; b: B[]; }
>{ a: ["x", "y"] } : { a: string[]; }
>a : string[]
>["x", "y"] : string[]
>"x" : "x"
>"y" : "y"

declare function testConstraints2<A extends string, B extends A>(arg?: { a?: A[], b?: B[] }): { a: A[], b: B[] }
>testConstraints2 : <A extends string, B extends A>(arg?: { a?: A[]; b?: B[]; }) => { a: A[]; b: B[]; }
>arg : { a?: A[]; b?: B[]; }
>a : A[]
>b : B[]
>a : A[]
>b : B[]

const expectAllowed1 = testConstraints2<infer, "x"> ({ a: ["x", "y"] }); // OK { a: string[], b: "x"[] }
>expectAllowed1 : { a: ("x" | "y")[]; b: "x"[]; }
>testConstraints2<infer, "x"> ({ a: ["x", "y"] }) : { a: ("x" | "y")[]; b: "x"[]; }
>testConstraints2 : <A extends string, B extends A>(arg?: { a?: A[]; b?: B[]; }) => { a: A[]; b: B[]; }
>{ a: ["x", "y"] } : { a: ("x" | "y")[]; }
>a : ("x" | "y")[]
>["x", "y"] : ("x" | "y")[]
>"x" : "x"
>"y" : "y"

const expectAllowed2 = testConstraints2<"x" | "y", infer> ({ b: ["x"] }); // OK { a: ("x" | "y")[], b: ("x" | "y")[] }
>expectAllowed2 : { a: ("x" | "y")[]; b: "x"[]; }
>testConstraints2<"x" | "y", infer> ({ b: ["x"] }) : { a: ("x" | "y")[]; b: "x"[]; }
>testConstraints2 : <A extends string, B extends A>(arg?: { a?: A[]; b?: B[]; }) => { a: A[]; b: B[]; }
>{ b: ["x"] } : { b: "x"[]; }
>b : "x"[]
>["x"] : "x"[]
>"x" : "x"

const expectAllowed3 = testConstraints2<infer, "z"> ({ a: ["x", "y"] }); // OK - inference fails, but that just makes A = string, which still passes
>expectAllowed3 : { a: string[]; b: "z"[]; }
>testConstraints2<infer, "z"> ({ a: ["x", "y"] }) : { a: string[]; b: "z"[]; }
>testConstraints2 : <A extends string, B extends A>(arg?: { a?: A[]; b?: B[]; }) => { a: A[]; b: B[]; }
>{ a: ["x", "y"] } : { a: string[]; }
>a : string[]
>["x", "y"] : string[]
>"x" : "x"
>"y" : "y"

const expectError2 = testConstraints2<"x" | "y", infer> ({ b: ["x", "y", "z"] }); // error "z" not in "x" | "y"
>expectError2 : any
>testConstraints2<"x" | "y", infer> ({ b: ["x", "y", "z"] }) : any
>testConstraints2 : <A extends string, B extends A>(arg?: { a?: A[]; b?: B[]; }) => { a: A[]; b: B[]; }
>{ b: ["x", "y", "z"] } : { b: string[]; }
>b : string[]
>["x", "y", "z"] : string[]
>"x" : "x"
>"y" : "y"
>"z" : "z"

declare function complexConstraints<A extends string, B extends A, C extends B>(arg: { a?: A[], b?: B[], c?: C[] }): { a: A[], b: B[], c: C[] };
>complexConstraints : <A extends string, B extends A, C extends B>(arg: { a?: A[]; b?: B[]; c?: C[]; }) => { a: A[]; b: B[]; c: C[]; }
>arg : { a?: A[]; b?: B[]; c?: C[]; }
>a : A[]
>b : B[]
>c : C[]
>a : A[]
>b : B[]
>c : C[]

const expectAllowed4 = complexConstraints<"x" | "y" | "z", infer, infer> ({ a: ["x"], c: ["x", "y"] }); // OK { a: ("x" | "y" | "z")[], b: ("x" | "y" | "z")[], c: ("x" | "y")[] }
>expectAllowed4 : { a: ("z" | "x" | "y")[]; b: ("z" | "x" | "y")[]; c: ("x" | "y")[]; }
>complexConstraints<"x" | "y" | "z", infer, infer> ({ a: ["x"], c: ["x", "y"] }) : { a: ("z" | "x" | "y")[]; b: ("z" | "x" | "y")[]; c: ("x" | "y")[]; }
>complexConstraints : <A extends string, B extends A, C extends B>(arg: { a?: A[]; b?: B[]; c?: C[]; }) => { a: A[]; b: B[]; c: C[]; }
>{ a: ["x"], c: ["x", "y"] } : { a: "x"[]; c: ("x" | "y")[]; }
>a : "x"[]
>["x"] : "x"[]
>"x" : "x"
>c : ("x" | "y")[]
>["x", "y"] : ("x" | "y")[]
>"x" : "x"
>"y" : "y"

// OK because B inferred to be "x" but that conflicts with C as "x" | "y" so inference fails - A and C are provided,
// B becomes its constraint, A, or "x" | "y" | "z", and the call successfully resolves
const expectAlllowed5 = complexConstraints<"x" | "y" | "z", infer, "x" | "y">({b: ["x"]});
>expectAlllowed5 : { a: ("z" | "x" | "y")[]; b: ("z" | "x" | "y")[]; c: ("x" | "y")[]; }
>complexConstraints<"x" | "y" | "z", infer, "x" | "y">({b: ["x"]}) : { a: ("z" | "x" | "y")[]; b: ("z" | "x" | "y")[]; c: ("x" | "y")[]; }
>complexConstraints : <A extends string, B extends A, C extends B>(arg: { a?: A[]; b?: B[]; c?: C[]; }) => { a: A[]; b: B[]; c: C[]; }
>{b: ["x"]} : { b: "x"[]; }
>b : "x"[]
>["x"] : "x"[]
>"x" : "x"

const expectError3 = complexConstraints<"x", infer, infer>({c: ["y"]}); // error "y" does not extend "x"
>expectError3 : any
>complexConstraints<"x", infer, infer>({c: ["y"]}) : any
>complexConstraints : <A extends string, B extends A, C extends B>(arg: { a?: A[]; b?: B[]; c?: C[]; }) => { a: A[]; b: B[]; c: C[]; }
>{c: ["y"]} : { c: string[]; }
>c : string[]
>["y"] : string[]
>"y" : "y"

type BadConditional = string extends { toString(): infer } ? true : false; // Must name infer target in conditionals
>BadConditional : false
>toString : () => ?
>true : true
>false : false

