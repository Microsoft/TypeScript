=== tests/cases/compiler/outOfBoundTupleIndexTypeIsUndefined.ts ===
type T = [number, boolean] & { x: number };
>T : Symbol(T, Decl(outOfBoundTupleIndexTypeIsUndefined.ts, 0, 0))
>x : Symbol(x, Decl(outOfBoundTupleIndexTypeIsUndefined.ts, 0, 30))

type U = [number, boolean] & { [2]: number };
>U : Symbol(U, Decl(outOfBoundTupleIndexTypeIsUndefined.ts, 0, 43))
>[2] : Symbol([2], Decl(outOfBoundTupleIndexTypeIsUndefined.ts, 1, 30))
>2 : Symbol([2], Decl(outOfBoundTupleIndexTypeIsUndefined.ts, 1, 30))

declare const t: T;
>t : Symbol(t, Decl(outOfBoundTupleIndexTypeIsUndefined.ts, 3, 13))
>T : Symbol(T, Decl(outOfBoundTupleIndexTypeIsUndefined.ts, 0, 0))

const a = t[0]; // number
>a : Symbol(a, Decl(outOfBoundTupleIndexTypeIsUndefined.ts, 4, 5))
>t : Symbol(t, Decl(outOfBoundTupleIndexTypeIsUndefined.ts, 3, 13))
>0 : Symbol(0)

const b = t[1]; // boolean
>b : Symbol(b, Decl(outOfBoundTupleIndexTypeIsUndefined.ts, 5, 5))
>t : Symbol(t, Decl(outOfBoundTupleIndexTypeIsUndefined.ts, 3, 13))
>1 : Symbol(1)

const c = t[2]; // undefined
>c : Symbol(c, Decl(outOfBoundTupleIndexTypeIsUndefined.ts, 6, 5))
>t : Symbol(t, Decl(outOfBoundTupleIndexTypeIsUndefined.ts, 3, 13))

const x: T[2] = 0 // error
>x : Symbol(x, Decl(outOfBoundTupleIndexTypeIsUndefined.ts, 8, 5))
>T : Symbol(T, Decl(outOfBoundTupleIndexTypeIsUndefined.ts, 0, 0))

const y: U[2] = 0 // no error
>y : Symbol(y, Decl(outOfBoundTupleIndexTypeIsUndefined.ts, 9, 5))
>U : Symbol(U, Decl(outOfBoundTupleIndexTypeIsUndefined.ts, 0, 43))

